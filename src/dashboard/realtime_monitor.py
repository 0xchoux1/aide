"""
AIDE „É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†

„É°„Éà„É™„ÇØ„ÇπÁõ£Ë¶ñ„ÄÅ„Ç¢„É©„Éº„Éà„ÄÅÈÄöÁü•Ê©üËÉΩ
"""

import time
import threading
import json
from typing import Dict, List, Optional, Any, Callable, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
import queue
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from ..config import get_config_manager
from ..logging import get_logger, get_audit_logger
from .metrics_collector import get_metrics_collector, MetricsCollector, MetricSeries


class AlertSeverity(Enum):
    """„Ç¢„É©„Éº„ÉàÈáçË¶ÅÂ∫¶"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


class ThresholdType(Enum):
    """ÈñæÂÄ§„Çø„Ç§„Éó"""
    ABSOLUTE = "absolute"      # Áµ∂ÂØæÂÄ§
    PERCENTAGE = "percentage"  # „Éë„Éº„Çª„É≥„ÉÜ„Éº„Ç∏
    RATE = "rate"             # Â§âÂåñÁéá
    TREND = "trend"           # „Éà„É¨„É≥„Éâ


class ComparisonOperator(Enum):
    """ÊØîËºÉÊºîÁÆóÂ≠ê"""
    GREATER_THAN = ">"
    LESS_THAN = "<"
    GREATER_EQUAL = ">="
    LESS_EQUAL = "<="
    EQUAL = "=="
    NOT_EQUAL = "!="


@dataclass
class MetricThreshold:
    """„É°„Éà„É™„ÇØ„ÇπÈñæÂÄ§"""
    metric_name: str
    operator: ComparisonOperator
    value: float
    threshold_type: ThresholdType = ThresholdType.ABSOLUTE
    duration_seconds: int = 60  # Á∂ôÁ∂öÊôÇÈñì
    description: str = ""
    
    def check(self, current_value: float, historical_values: List[float] = None) -> bool:
        """ÈñæÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ"""
        if self.threshold_type == ThresholdType.ABSOLUTE:
            return self._compare(current_value, self.value)
        
        elif self.threshold_type == ThresholdType.PERCENTAGE:
            # „Éë„Éº„Çª„É≥„ÉÜ„Éº„Ç∏Â§âÂåñ
            if not historical_values or len(historical_values) < 2:
                return False
            
            previous_value = historical_values[-2]
            if previous_value == 0:
                return False
            
            percentage_change = ((current_value - previous_value) / previous_value) * 100
            return self._compare(percentage_change, self.value)
        
        elif self.threshold_type == ThresholdType.RATE:
            # Â§âÂåñÁéá
            if not historical_values or len(historical_values) < 2:
                return False
            
            previous_value = historical_values[-2]
            rate_of_change = current_value - previous_value
            return self._compare(rate_of_change, self.value)
        
        elif self.threshold_type == ThresholdType.TREND:
            # „Éà„É¨„É≥„ÉâÂàÜÊûêÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
            if not historical_values or len(historical_values) < 3:
                return False
            
            # Áõ¥Ëøë3ÁÇπ„ÅÆÂπ≥ÂùáÂÇæÂêë
            recent_values = historical_values[-3:]
            trend = (recent_values[-1] - recent_values[0]) / 2
            return self._compare(trend, self.value)
        
        return False
    
    def _compare(self, value1: float, value2: float) -> bool:
        """ÂÄ§ÊØîËºÉ"""
        if self.operator == ComparisonOperator.GREATER_THAN:
            return value1 > value2
        elif self.operator == ComparisonOperator.LESS_THAN:
            return value1 < value2
        elif self.operator == ComparisonOperator.GREATER_EQUAL:
            return value1 >= value2
        elif self.operator == ComparisonOperator.LESS_EQUAL:
            return value1 <= value2
        elif self.operator == ComparisonOperator.EQUAL:
            return abs(value1 - value2) < 0.001  # ÊµÆÂãïÂ∞èÊï∞ÁÇπË™§Â∑ÆËÄÉÊÖÆ
        elif self.operator == ComparisonOperator.NOT_EQUAL:
            return abs(value1 - value2) >= 0.001
        
        return False


@dataclass
class AlertRule:
    """„Ç¢„É©„Éº„Éà„É´„Éº„É´"""
    rule_id: str
    name: str
    description: str
    threshold: MetricThreshold
    severity: AlertSeverity
    enabled: bool = True
    cooldown_minutes: int = 10  # „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥ÊúüÈñì
    notification_channels: List[str] = None
    
    def __post_init__(self):
        if self.notification_channels is None:
            self.notification_channels = []
    
    def to_dict(self) -> Dict[str, Any]:
        """ËæûÊõ∏ÂΩ¢Âºè„Å´Â§âÊèõ"""
        data = asdict(self)
        data['threshold']['operator'] = self.threshold.operator.value
        data['threshold']['threshold_type'] = self.threshold.threshold_type.value
        data['severity'] = self.severity.value
        return data


@dataclass
class AlertEvent:
    """„Ç¢„É©„Éº„Éà„Ç§„Éô„É≥„Éà"""
    event_id: str
    rule_id: str
    metric_name: str
    severity: AlertSeverity
    message: str
    current_value: float
    threshold_value: float
    timestamp: float
    resolved: bool = False
    resolved_timestamp: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """ËæûÊõ∏ÂΩ¢Âºè„Å´Â§âÊèõ"""
        data = asdict(self)
        data['severity'] = self.severity.value
        return data


class NotificationChannel:
    """ÈÄöÁü•„ÉÅ„É£„Éç„É´Âü∫Â∫ï„ÇØ„É©„Çπ"""
    
    def __init__(self, channel_id: str, name: str):
        self.channel_id = channel_id
        self.name = name
        self.logger = get_logger(__name__)
    
    async def send_notification(self, alert: AlertEvent, rule: AlertRule) -> bool:
        """ÈÄöÁü•ÈÄÅ‰ø°Ôºà„Çµ„Éñ„ÇØ„É©„Çπ„ÅßÂÆüË£ÖÔºâ"""
        raise NotImplementedError


class ConsoleNotificationChannel(NotificationChannel):
    """„Ç≥„É≥„ÇΩ„Éº„É´ÈÄöÁü•„ÉÅ„É£„Éç„É´"""
    
    def __init__(self):
        super().__init__("console", "Console Output")
    
    async def send_notification(self, alert: AlertEvent, rule: AlertRule) -> bool:
        """„Ç≥„É≥„ÇΩ„Éº„É´ÈÄöÁü•"""
        severity_icons = {
            AlertSeverity.INFO: "‚ÑπÔ∏è",
            AlertSeverity.WARNING: "‚ö†Ô∏è",
            AlertSeverity.CRITICAL: "üö®",
            AlertSeverity.EMERGENCY: "üÜò"
        }
        
        icon = severity_icons.get(alert.severity, "üîî")
        timestamp = datetime.fromtimestamp(alert.timestamp).strftime("%Y-%m-%d %H:%M:%S")
        
        print(f"\n{icon} ALERT [{alert.severity.value.upper()}] - {timestamp}")
        print(f"Rule: {rule.name}")
        print(f"Metric: {alert.metric_name}")
        print(f"Current Value: {alert.current_value}")
        print(f"Threshold: {rule.threshold.operator.value} {alert.threshold_value}")
        print(f"Message: {alert.message}")
        print("-" * 50)
        
        return True


class EmailNotificationChannel(NotificationChannel):
    """„É°„Éº„É´ÈÄöÁü•„ÉÅ„É£„Éç„É´"""
    
    def __init__(self, smtp_server: str, smtp_port: int, 
                 username: str, password: str, from_email: str, to_emails: List[str]):
        super().__init__("email", "Email Notification")
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_email = from_email
        self.to_emails = to_emails
    
    async def send_notification(self, alert: AlertEvent, rule: AlertRule) -> bool:
        """„É°„Éº„É´ÈÄöÁü•"""
        try:
            # „É°„Éº„É´‰ΩúÊàê
            msg = MIMEMultipart()
            msg['From'] = self.from_email
            msg['To'] = ', '.join(self.to_emails)
            msg['Subject'] = f"AIDE Alert: {rule.name} [{alert.severity.value.upper()}]"
            
            # „É°„Éº„É´Êú¨Êñá
            body = self._create_email_body(alert, rule)
            msg.attach(MIMEText(body, 'html'))
            
            # SMTPÈÄÅ‰ø°
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.username, self.password)
                server.send_message(msg)
            
            self.logger.info(f"„Ç¢„É©„Éº„Éà„É°„Éº„É´ÈÄÅ‰ø°ÊàêÂäü: {alert.event_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"„É°„Éº„É´ÈÄÅ‰ø°„Ç®„É©„Éº: {str(e)}")
            return False
    
    def _create_email_body(self, alert: AlertEvent, rule: AlertRule) -> str:
        """„É°„Éº„É´Êú¨Êñá‰ΩúÊàê"""
        timestamp = datetime.fromtimestamp(alert.timestamp).strftime("%Y-%m-%d %H:%M:%S")
        
        severity_colors = {
            AlertSeverity.INFO: "#17a2b8",
            AlertSeverity.WARNING: "#ffc107",
            AlertSeverity.CRITICAL: "#dc3545",
            AlertSeverity.EMERGENCY: "#6f42c1"
        }
        
        color = severity_colors.get(alert.severity, "#6c757d")
        
        return f"""
        <html>
        <body style="font-family: Arial, sans-serif; margin: 20px;">
            <div style="border-left: 4px solid {color}; padding-left: 20px;">
                <h2 style="color: {color};">AIDE „Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà</h2>
                
                <table style="border-collapse: collapse; width: 100%; margin-top: 20px;">
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">ÈáçË¶ÅÂ∫¶:</td>
                        <td style="padding: 8px; color: {color}; font-weight: bold;">{alert.severity.value.upper()}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">„É´„Éº„É´Âêç:</td>
                        <td style="padding: 8px;">{rule.name}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">„É°„Éà„É™„ÇØ„Çπ:</td>
                        <td style="padding: 8px;">{alert.metric_name}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">ÁèæÂú®ÂÄ§:</td>
                        <td style="padding: 8px;">{alert.current_value}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">ÈñæÂÄ§:</td>
                        <td style="padding: 8px;">{rule.threshold.operator.value} {alert.threshold_value}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; font-weight: bold; background-color: #f8f9fa;">ÊôÇÂàª:</td>
                        <td style="padding: 8px;">{timestamp}</td>
                    </tr>
                </table>
                
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                    <strong>„É°„ÉÉ„Çª„Éº„Ç∏:</strong><br>
                    {alert.message}
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background-color: #e9ecef; border-radius: 5px;">
                    <strong>Ë™¨Êòé:</strong><br>
                    {rule.description}
                </div>
            </div>
            
            <p style="margin-top: 30px; font-size: 12px; color: #6c757d;">
                „Åì„ÅÆ„É°„Éº„É´„ÅØAIDE„Ç∑„Çπ„ÉÜ„É†„Åã„ÇâËá™ÂãïÈÄÅ‰ø°„Åï„Çå„Åæ„Åó„Åü„ÄÇ
            </p>
        </body>
        </html>
        """


class WebhookNotificationChannel(NotificationChannel):
    """WebhookÈÄöÁü•„ÉÅ„É£„Éç„É´"""
    
    def __init__(self, webhook_url: str, headers: Optional[Dict[str, str]] = None):
        super().__init__("webhook", "Webhook Notification")
        self.webhook_url = webhook_url
        self.headers = headers or {}
    
    async def send_notification(self, alert: AlertEvent, rule: AlertRule) -> bool:
        """WebhookÈÄöÁü•"""
        try:
            import requests
            
            payload = {
                "alert": alert.to_dict(),
                "rule": rule.to_dict(),
                "timestamp": alert.timestamp,
                "source": "AIDE"
            }
            
            response = requests.post(
                self.webhook_url,
                json=payload,
                headers=self.headers,
                timeout=10
            )
            
            if response.status_code == 200:
                self.logger.info(f"WebhookÈÄöÁü•ÈÄÅ‰ø°ÊàêÂäü: {alert.event_id}")
                return True
            else:
                self.logger.error(f"WebhookÈÄöÁü•Â§±Êïó: {response.status_code}")
                return False
                
        except Exception as e:
            self.logger.error(f"WebhookÈÄÅ‰ø°„Ç®„É©„Éº: {str(e)}")
            return False


class RealtimeMonitor:
    """„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self, metrics_collector: Optional[MetricsCollector] = None):
        self.metrics_collector = metrics_collector or get_metrics_collector()
        self.logger = get_logger(__name__)
        self.audit_logger = get_audit_logger()
        
        # „Ç¢„É©„Éº„Éà„É´„Éº„É´
        self.alert_rules: Dict[str, AlertRule] = {}
        
        # ÈÄöÁü•„ÉÅ„É£„Éç„É´
        self.notification_channels: Dict[str, NotificationChannel] = {}
        
        # „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç¢„É©„Éº„Éà
        self.active_alerts: Dict[str, AlertEvent] = {}
        
        # „Ç¢„É©„Éº„ÉàÂ±•Ê≠¥
        self.alert_history: List[AlertEvent] = []
        
        # „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥ÁÆ°ÁêÜ
        self.cooldown_tracker: Dict[str, float] = {}
        
        # Áõ£Ë¶ñ„Çπ„É¨„ÉÉ„Éâ
        self.monitor_thread = None
        self.stop_event = threading.Event()
        self.is_running = False
        
        # Ë®≠ÂÆö
        self.config_manager = get_config_manager()
        self.check_interval = self.config_manager.get(
            "monitoring.check_interval_seconds", 30
        )
        
        # „Éá„Éï„Ç©„É´„ÉàÈÄöÁü•„ÉÅ„É£„Éç„É´ËøΩÂä†
        self.add_notification_channel(ConsoleNotificationChannel())
        
        # „Éá„Éï„Ç©„É´„Éà„É´„Éº„É´ËøΩÂä†
        self._setup_default_rules()
    
    def _setup_default_rules(self):
        """„Éá„Éï„Ç©„É´„Éà„Ç¢„É©„Éº„Éà„É´„Éº„É´Ë®≠ÂÆö"""
        # CPU‰ΩøÁî®Áéá„Ç¢„É©„Éº„Éà
        self.add_alert_rule(AlertRule(
            rule_id="cpu_high",
            name="CPU‰ΩøÁî®ÁéáÈ´ò",
            description="CPU‰ΩøÁî®Áéá„Åå80%„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô",
            threshold=MetricThreshold(
                metric_name="system_cpu_usage",
                operator=ComparisonOperator.GREATER_THAN,
                value=80.0,
                duration_seconds=60
            ),
            severity=AlertSeverity.WARNING,
            notification_channels=["console"]
        ))
        
        # „É°„É¢„É™‰ΩøÁî®Áéá„Ç¢„É©„Éº„Éà
        self.add_alert_rule(AlertRule(
            rule_id="memory_high",
            name="„É°„É¢„É™‰ΩøÁî®ÁéáÈ´ò",
            description="„É°„É¢„É™‰ΩøÁî®Áéá„Åå85%„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô",
            threshold=MetricThreshold(
                metric_name="system_memory_usage",
                operator=ComparisonOperator.GREATER_THAN,
                value=85.0,
                duration_seconds=60
            ),
            severity=AlertSeverity.CRITICAL,
            notification_channels=["console"]
        ))
        
        # „Éá„Ç£„Çπ„ÇØ‰ΩøÁî®Áéá„Ç¢„É©„Éº„Éà
        self.add_alert_rule(AlertRule(
            rule_id="disk_high",
            name="„Éá„Ç£„Çπ„ÇØ‰ΩøÁî®ÁéáÈ´ò",
            description="„Éá„Ç£„Çπ„ÇØ‰ΩøÁî®Áéá„Åå90%„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô",
            threshold=MetricThreshold(
                metric_name="system_disk_usage",
                operator=ComparisonOperator.GREATER_THAN,
                value=90.0,
                duration_seconds=60
            ),
            severity=AlertSeverity.CRITICAL,
            notification_channels=["console"]
        ))
        
        # „É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì„Ç¢„É©„Éº„Éà
        self.add_alert_rule(AlertRule(
            rule_id="response_time_high",
            name="„É¨„Çπ„Éù„É≥„ÇπÊôÇÈñìÈ´ò",
            description="Âπ≥Âùá„É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì„Åå2Áßí„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô",
            threshold=MetricThreshold(
                metric_name="response_time",
                operator=ComparisonOperator.GREATER_THAN,
                value=2000.0,  # „Éü„É™Áßí
                duration_seconds=120
            ),
            severity=AlertSeverity.WARNING,
            notification_channels=["console"]
        ))
        
        # „Éò„É´„Çπ„Çπ„Ç≥„Ç¢‰Ωé‰∏ã„Ç¢„É©„Éº„Éà
        self.add_alert_rule(AlertRule(
            rule_id="health_score_low",
            name="„Éò„É´„Çπ„Çπ„Ç≥„Ç¢‰Ωé‰∏ã",
            description="„Ç∑„Çπ„ÉÜ„É†„Éò„É´„Çπ„Çπ„Ç≥„Ç¢„Åå50„Çí‰∏ãÂõû„Çä„Åæ„Åó„Åü",
            threshold=MetricThreshold(
                metric_name="health_score",
                operator=ComparisonOperator.LESS_THAN,
                value=50.0,
                duration_seconds=60
            ),
            severity=AlertSeverity.CRITICAL,
            notification_channels=["console"]
        ))
    
    def add_alert_rule(self, rule: AlertRule):
        """„Ç¢„É©„Éº„Éà„É´„Éº„É´ËøΩÂä†"""
        self.alert_rules[rule.rule_id] = rule
        self.logger.info(f"„Ç¢„É©„Éº„Éà„É´„Éº„É´ËøΩÂä†: {rule.name}")
    
    def remove_alert_rule(self, rule_id: str):
        """„Ç¢„É©„Éº„Éà„É´„Éº„É´ÂâäÈô§"""
        if rule_id in self.alert_rules:
            rule = self.alert_rules.pop(rule_id)
            self.logger.info(f"„Ç¢„É©„Éº„Éà„É´„Éº„É´ÂâäÈô§: {rule.name}")
            return True
        return False
    
    def add_notification_channel(self, channel: NotificationChannel):
        """ÈÄöÁü•„ÉÅ„É£„Éç„É´ËøΩÂä†"""
        self.notification_channels[channel.channel_id] = channel
        self.logger.info(f"ÈÄöÁü•„ÉÅ„É£„Éç„É´ËøΩÂä†: {channel.name}")
    
    def start_monitoring(self):
        """Áõ£Ë¶ñÈñãÂßã"""
        if self.is_running:
            self.logger.warning("Áõ£Ë¶ñ„ÅØÊó¢„Å´ÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô")
            return
        
        self.stop_event.clear()
        self.monitor_thread = threading.Thread(
            target=self._monitoring_loop,
            daemon=True
        )
        self.monitor_thread.start()
        self.is_running = True
        
        self.logger.info("„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñÈñãÂßã")
        self.audit_logger.log_system_event("monitoring_start", "„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñÈñãÂßã")
    
    def stop_monitoring(self):
        """Áõ£Ë¶ñÂÅúÊ≠¢"""
        if not self.is_running:
            return
        
        self.stop_event.set()
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5.0)
        
        self.is_running = False
        self.logger.info("„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñÂÅúÊ≠¢")
        self.audit_logger.log_system_event("monitoring_stop", "„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñÂÅúÊ≠¢")
    
    def _monitoring_loop(self):
        """Áõ£Ë¶ñ„É´„Éº„Éó"""
        while not self.stop_event.is_set():
            try:
                self._check_all_rules()
                self._resolve_alerts()
            except Exception as e:
                self.logger.error(f"Áõ£Ë¶ñ„É´„Éº„Éó„Ç®„É©„Éº: {str(e)}")
            
            self.stop_event.wait(self.check_interval)
    
    def _check_all_rules(self):
        """ÂÖ®„É´„Éº„É´„ÉÅ„Çß„ÉÉ„ÇØ"""
        for rule in self.alert_rules.values():
            if not rule.enabled:
                continue
            
            # „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„ÉÅ„Çß„ÉÉ„ÇØ
            if self._is_in_cooldown(rule.rule_id):
                continue
            
            self._check_rule(rule)
    
    def _check_rule(self, rule: AlertRule):
        """ÂÄãÂà•„É´„Éº„É´„ÉÅ„Çß„ÉÉ„ÇØ"""
        metric_series = self.metrics_collector.get_metric_series(rule.threshold.metric_name)
        
        if not metric_series or not metric_series.points:
            return
        
        # ÁèæÂú®ÂÄ§ÂèñÂæó
        latest_point = metric_series.get_latest()
        current_value = latest_point.value
        
        # Â±•Ê≠¥ÂÄ§ÂèñÂæóÔºà„Éà„É¨„É≥„ÉâÂàÜÊûêÁî®Ôºâ
        now = time.time()
        historical_points = metric_series.get_points_in_range(
            now - rule.threshold.duration_seconds, 
            now
        )
        historical_values = [p.value for p in historical_points]
        
        # ÈñæÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
        if rule.threshold.check(current_value, historical_values):
            self._trigger_alert(rule, current_value)
    
    def _trigger_alert(self, rule: AlertRule, current_value: float):
        """„Ç¢„É©„Éº„ÉàÁô∫Áîü"""
        # Êó¢Â≠ò„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç¢„É©„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ
        if rule.rule_id in self.active_alerts:
            return
        
        # „Ç¢„É©„Éº„Éà„Ç§„Éô„É≥„Éà‰ΩúÊàê
        event_id = f"{rule.rule_id}_{int(time.time())}"
        alert = AlertEvent(
            event_id=event_id,
            rule_id=rule.rule_id,
            metric_name=rule.threshold.metric_name,
            severity=rule.severity,
            message=f"{rule.name}: {rule.threshold.metric_name} = {current_value} {rule.threshold.operator.value} {rule.threshold.value}",
            current_value=current_value,
            threshold_value=rule.threshold.value,
            timestamp=time.time()
        )
        
        # „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç¢„É©„Éº„Éà„Å´ËøΩÂä†
        self.active_alerts[rule.rule_id] = alert
        self.alert_history.append(alert)
        
        # „É≠„Ç∞Ë®òÈå≤
        self.logger.warning(f"„Ç¢„É©„Éº„ÉàÁô∫Áîü: {alert.message}")
        self.audit_logger.log_event(
            "alert_triggered",
            f"„Ç¢„É©„Éº„ÉàÁô∫Áîü: {rule.name}",
            severity="high",
            rule_id=rule.rule_id,
            metric_name=rule.threshold.metric_name,
            current_value=current_value,
            threshold_value=rule.threshold.value
        )
        
        # ÈÄöÁü•ÈÄÅ‰ø°
        self._send_notifications(alert, rule)
        
        # „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Ë®≠ÂÆö
        self.cooldown_tracker[rule.rule_id] = time.time() + (rule.cooldown_minutes * 60)
    
    def _send_notifications(self, alert: AlertEvent, rule: AlertRule):
        """ÈÄöÁü•ÈÄÅ‰ø°"""
        for channel_id in rule.notification_channels:
            if channel_id in self.notification_channels:
                channel = self.notification_channels[channel_id]
                
                try:
                    # ÈùûÂêåÊúüÂÆüË°åÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
                    import asyncio
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    success = loop.run_until_complete(
                        channel.send_notification(alert, rule)
                    )
                    loop.close()
                    
                    if success:
                        self.logger.info(f"ÈÄöÁü•ÈÄÅ‰ø°ÊàêÂäü: {channel.name}")
                    else:
                        self.logger.error(f"ÈÄöÁü•ÈÄÅ‰ø°Â§±Êïó: {channel.name}")
                        
                except Exception as e:
                    self.logger.error(f"ÈÄöÁü•ÈÄÅ‰ø°„Ç®„É©„Éº ({channel.name}): {str(e)}")
    
    def _resolve_alerts(self):
        """„Ç¢„É©„Éº„ÉàËß£Ê±∫„ÉÅ„Çß„ÉÉ„ÇØ"""
        resolved_alerts = []
        
        for rule_id, alert in self.active_alerts.items():
            rule = self.alert_rules.get(rule_id)
            if not rule:
                resolved_alerts.append(rule_id)
                continue
            
            # „É°„Éà„É™„ÇØ„ÇπÁ¢∫Ë™ç
            metric_series = self.metrics_collector.get_metric_series(rule.threshold.metric_name)
            if not metric_series or not metric_series.points:
                continue
            
            latest_point = metric_series.get_latest()
            current_value = latest_point.value
            
            # Â±•Ê≠¥ÂÄ§ÂèñÂæó
            now = time.time()
            historical_points = metric_series.get_points_in_range(
                now - rule.threshold.duration_seconds,
                now
            )
            historical_values = [p.value for p in historical_points]
            
            # ÈñæÂÄ§„Çí‰∏ãÂõû„Å£„ÅüÂ†¥Âêà„ÅØËß£Ê±∫
            if not rule.threshold.check(current_value, historical_values):
                alert.resolved = True
                alert.resolved_timestamp = time.time()
                resolved_alerts.append(rule_id)
                
                self.logger.info(f"„Ç¢„É©„Éº„ÉàËß£Ê±∫: {alert.message}")
                self.audit_logger.log_event(
                    "alert_resolved",
                    f"„Ç¢„É©„Éº„ÉàËß£Ê±∫: {rule.name}",
                    severity="medium",
                    rule_id=rule_id,
                    resolution_time=alert.resolved_timestamp - alert.timestamp
                )
        
        # Ëß£Ê±∫Ê∏à„Åø„Ç¢„É©„Éº„Éà„ÇíÂâäÈô§
        for rule_id in resolved_alerts:
            self.active_alerts.pop(rule_id, None)
    
    def _is_in_cooldown(self, rule_id: str) -> bool:
        """„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„ÅãÂà§ÂÆö"""
        if rule_id not in self.cooldown_tracker:
            return False
        
        return time.time() < self.cooldown_tracker[rule_id]
    
    def get_active_alerts(self) -> List[AlertEvent]:
        """„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç¢„É©„Éº„ÉàÂèñÂæó"""
        return list(self.active_alerts.values())
    
    def get_alert_history(self, limit: int = 100) -> List[AlertEvent]:
        """„Ç¢„É©„Éº„ÉàÂ±•Ê≠¥ÂèñÂæó"""
        return self.alert_history[-limit:]
    
    def get_monitoring_status(self) -> Dict[str, Any]:
        """Áõ£Ë¶ñÁä∂ÊÖãÂèñÂæó"""
        return {
            "is_running": self.is_running,
            "total_rules": len(self.alert_rules),
            "enabled_rules": len([r for r in self.alert_rules.values() if r.enabled]),
            "active_alerts": len(self.active_alerts),
            "notification_channels": len(self.notification_channels),
            "check_interval": self.check_interval,
            "alert_history_count": len(self.alert_history)
        }


# „Ç∞„É≠„Éº„Éê„É´Áõ£Ë¶ñ„Ç§„É≥„Çπ„Çø„É≥„Çπ
_global_monitor: Optional[RealtimeMonitor] = None


def get_realtime_monitor() -> RealtimeMonitor:
    """„Ç∞„É≠„Éº„Éê„É´Áõ£Ë¶ñ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂèñÂæó"""
    global _global_monitor
    if _global_monitor is None:
        _global_monitor = RealtimeMonitor()
    return _global_monitor